## 模板系统

### `_.noConflict()`： 将`_`对象的所有权交还

__源码__：

```js
_.noConflict = function () {
    // 回复原来的_指代的对象
    root._ = previousUnderscore;
    // 返回underscore对象
    return this;
};
```

假定在我们的工程中，已经**占据**了`_`对象，那么，之后我们引入underscore，`_`就会被underscore夺走：

```js
_ = {
    owner: 'wxj'
};

// 引入underscore后

console.log(_.owner); // => undefined
```

`_.noConflict`能够返回被underscore占据的`_`，并重新制定underscore对象：

```js
var underscore = _.noConflict();

console.log(_.owner); // => 'wxj'
```

### `_.identity(value)`：返回`value`本身

__源码__：

```js
_.identity = function (value) {
    return value;
};
```

很多没接触过FP编程的开发者看到这个方法会很诧异，要获得值本身的话，直接用`value`不就好，干嘛还有包一层函数？假定有这样一个情景，我们想要复制一个数组：

```js
var arr = [1,2,3,4,5];
var dstArr = arr.map((item, index) => {
    return item;
});
```

而借助于`_.identity`方法，我们可以这样做：

```js
var arr = [1,2,3,4,5];
var dstArr = arr.map(_.identity);
```

### `_.constant(value)`：返回一个函数，该函数将返回`value`本身

__源码__：

```js
_.constant = function (value) {
    return function () {
        return value;
    };
};
```

似乎比`_.identity`更加过分，更加匪夷所思，因为`_.constant`又包了一层。但我们注意到，`_.constant`内部形成了什么？对的，一个闭包，他将为我们缓存住当时的`value`，最终返回的所谓**常量**不过就是当时缓存的值：

```js
var a = 2;
var getConstA = _.constant(a);

a = 3;
getConstA(); // => 2
```

### `_.noop`：一个空函数引用

**源码**：

```
_.noop = function () {
};
```

`_.noop`指向了一个空函数引用，避免了创建空函数时不必要的开销，也节省了可能存在的判断开销：

```js
var a = {
    doSomething: null;
};
a.doSomething = function() {console.log("doing");}
// 某个业务需要的地方，需要额外判断
_.isFunction(a.doSomething) && a.doSomething();
// 现在
var a = {
     doSomething: _.noop
};
a.doSomething = function() {console.log("doing");}
// 不再需要判断
a.doSomething();
```

### `_.propertyOf(obj)`：返回一个属性获得函数，该函数能够获得`obj`的属性

**源码**：

```js
_.propertyOf = function (obj) {
    return obj == null ? function () {
    } : function (key) {
        return obj[key];
    };
};
```

可能又有人觉得大材小用了，要获得对象属性直接用`.`操作符不就好了吗，比如`obj.name`，考虑一个场景，我们想要获得一个对象所有的值，传统的做法会是：

```js
var student = {
    name: 'wxj',
    age: 18
};
var values = _.keys(student).map((key) => student[key]); // ['wxj', 18]
```

借助于`_.propertyOf`，将可以这样做：

```js
getStudentProp = _.propertyOf(student);
var values = _.keys(student).map(getStudentProp);
```

### `_.matcher(attrs)`： 返回一个属性检测函数，用来判断对象是否具备指定的属性`attrs`

**源码**：

```js
_.matcher = _.matches = function (attrs) {
    attrs = _.extendOwn({}, attrs);
    return function (obj) {
        return _.isMatch(obj, attrs);
    };
};
```

**用例**：

```js
var student1 = {
    name: 'wxj',
    age: 24
};
var student2 = {
    name: 'lx',
    age: 13
};
var students = [student1, student2];
var ageMatcher = _.matcher({age: 13});
var valids = _.filter(students, ageMatcher);
// => [{name: 'lx', age: 13}]
```

### `_.times(n, iteratee)`：执行函数`iteratee``n`次，返回保存了每次执行结果的数组

**源码**：

```js
_.times = function (n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
};
```

从源码中可以看到，`iteratee`将会是一个迭代函数，并且其第一个参数将会被传入当前迭代的索引值。

**用例**：

```js
function getIndex(index) {
    return index;
}

var indexes = _.times(3, getIndex);
// => [0,1,2]
```