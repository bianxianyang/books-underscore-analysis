## 模板系统

### `_.noConflict()`： 将`_`对象的所有权交还

__源码__：

```js
_.noConflict = function () {
    // 回复原来的_指代的对象
    root._ = previousUnderscore;
    // 返回underscore对象
    return this;
};
```

假定在我们的工程中，已经**占据**了`_`对象，那么，之后我们引入underscore，`_`就会被underscore夺走：

```js
_ = {
    owner: 'wxj'
};

// 引入underscore后

console.log(_.owner); // => undefined
```

`_.noConflict`能够返回被underscore占据的`_`，并重新制定underscore对象：

```js
var underscore = _.noConflict();

console.log(_.owner); // => 'wxj'
```

### `_.identity(value)`：返回`value`本身

__源码__：

```js
_.identity = function (value) {
    return value;
};
```

很多没接触过FP编程的开发者看到这个方法会很诧异，要获得值本身的话，直接用`value`不就好，干嘛还有包一层函数？假定有这样一个情景，我们想要复制一个数组：

```js
var arr = [1,2,3,4,5];
var dstArr = arr.map((item, index) => {
    return item;
});
```

而借助于`_.identity`方法，我们可以这样做：

```js
var arr = [1,2,3,4,5];
var dstArr = arr.map(_.identity);
```

### `_.constant(value)`：返回一个函数，该函数将返回`value`本身

__源码__：

```js
_.constant = function (value) {
    return function () {
        return value;
    };
};
```

似乎比`_.identity`更加过分，更加匪夷所思，因为`_.constant`又包了一层。但我们注意到，`_.constant`内部形成了什么？对的，一个闭包，他将为我们缓存住当时的`value`，最终返回的所谓**常量**不过就是当时缓存的值：

```js
var a = 2;
var constObj = _.constant(a);

// 要获得obj的敞亮


```