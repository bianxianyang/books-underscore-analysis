## 模板系统

### 什么是模板


我喜欢这样描述模板引擎（系统）：

1. 给定一个模板字符串，不同于一般的字符串，该字符串存在一些__规则__，并且需要填充__数据__或者__逻辑__：
```js
const tpl = 'hello {{name}}'
```
`{{name}}`就描述了一个规则：插值（interpolation），`{{}}`括号内的变量将在之后被替换。
2. 通过一个渲染器对该模板进行渲染并返回最终需要呈现的内容，渲染器通常需要知道两件事儿：（1）待渲染模板 （2）待填充数据：
```js
const data = {name: 'wxj'};
const content = render(tpl, data);
// => 'hello wxj'
```

由此，，我们不难得出模板系统核心在于__规则__及__渲染器__。

### 实现一个基本的模板系统
#### 规则
有了上面的认识，我们现在可以着手开始实现一个基本的js模板系统，首先我们考虑定义规则：

- 插值：比如`{{name}}`直接用渲染数据进行替换，我们通过`{{}}`包裹

显然，解析规则我们需要利用到正则表达式，因此我们最终的规则定义如下：

```js
const rules = {
    interpolate: /{{([\s\S]+?)}}/
};

// 最终的匹配正则
const matcher = new RegExp([
    rules.interpolate.source
].join('|'), 'g');
```

### 渲染器
渲染器的核心逻辑很简单，就是遍历传入的**模板字符串**，当子串匹配到规则时，根据规则进行处理，最终返回一个新（渲染好的）字符串：

```js
function render (tpl, data) {
    return tpl.replace(matcher, (match, interpolate)=>{
        return data[interpolate];
    });
}
```

如此，我们就实现了一个最简单的模板系统，认识了模板最基本的要素，但是，该系统还十分单薄，我们需要对其进行优化。

### 优化：支持模板插入代码逻辑
上面我们实现的模板只能够对模板进行数据填充，假设我们有下面内容的模板：

```
Students:
{ for(i=0;i<students.length;i++)  }
    {{ students[i].name }}
```

期望该模板渲染的结果为：

```js
Students: wxj lcx
```

在该模板中，显然，我们支持了传入代码逻辑（一个`for`循环），并且设置其规则为通过`{}`进行包裹，为了能支持上述的模板，我们需要新建该规则:

```js
const rules = {
    // 插值
    interpolate: /{{([\s\S]+?)}}/,
    // 逻辑
    evaluate: /{([\s\S+?])}/function render(tpl, data) {
    // 拼接字符串
    let concating = `content +='`;
    let index = 0;
    tpl.replace(matcher, (match, interpolate, evaluate, offset) => {
        concating += tpl.slice(index, offset);
        // 刷新拼接起点
        index = offset + match.length;
        if(evaluate) {
            // 如果是执行逻辑
            concating += `';\n${evaluate}\n content +='`;
        } else if(interpolate) {
            // 如果是插值
            concating += `'+${interpolate}+'`;
        }
        return match;
    });
    // 剩余字符拼接
    concating += tpl.slice(index);
    concating += `';\n`;
    concating = `with(obj) {\n${concating}}`;
    // 通过函数来支持逻辑执行
    const body = `let content = ''; \n${concating}; \nreturn content;`;
    console.log(body);
    const renderFunc = new Function('obj', body);
    return renderFunc(data);
}
};

// 最终的匹配正则
const matcher = new RegExp([
    rules.interpolate.source,
    rules.evaluate.source
].join('|'), 'g');
```

渲染器现在就不单是进行字符串替换操作了，还应当支持执行传入的逻辑：

```js
function render(tpl, data) {
    // 拼接字符串
    let concating = `content +='`;
    let index = 0;
    tpl.replace(matcher, (match, interpolate, evaluate, offset) => {
        concating += tpl.slice(index, offset);
        // 刷新拼接起点
        index = offset + match.length;
        if(evaluate) {
            // 如果是执行逻辑
            concating += `';\n${evaluate}\n content +='`;
        } else if(interpolate) {
            // 如果是插值
            concating += `'+${interpolate}+'`;
        }
        return match;
    });
    // 剩余字符拼接
    concating += tpl.slice(index);
    concating += `';\n`;
    concating = `with(obj) {\n${concating}}`;
    // 通过函数来支持逻辑执行
    const body = `let content = ''; \n${concating}; \nreturn content;`;
    const renderFunc = new Function('obj', body);
    return renderFunc(data);
}
```

可以看到，通过[`new Function(arguments, body)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function)来动态构建渲染函数，我们支持了向模板传入执行逻辑。值得注意的是，我们给该构造函数传入两个参数：

- `obj`： 该参数为渲染函数的数据，通过[`with(expression)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with)，我们限定了函数体中的数据来源不会受到外部作用域的干扰。

- 'body'：该参数为渲染函数的函数体，由我们动态拼接而成。

现在，测试一下：

```js
const tpl = 'Students: ' +
'{ for(i=0;i<students.length;i++) }' +
'{{ students[i].name }} ';

data = {
    students: [{
        id:1,
        name: 'wxj'
    }, {
        id: 2,
        name: 'lcx'
    }]
};
const content = render(tpl, data);
// content: 'Students: wxj lcx'
```

### 优化：字符逃逸
在上述的模板系统中，我稍微修改了一下模板：

```
Students:
{ for(i=0;i<students.length;i++)  }
    {{ students[i].name }}
```

期望该模板渲染的结果为：

```js
Students: wxj lcx
```

再次尝试调用我们上一步我们写好的渲染器：

```
const tpl = 'Students: \n' +
'{ for(i=0;i<students.length;i++) }' +
'{{ students[i].name }} ';

const content = render(tpl, data);
```

很遗憾，报错了，原因就是出在了换行符`'\n'`上，我们拼接字符串的时候没有用反斜杠`\`对转义字符进行逃逸（escape）:

```js
// Error:
let body = `console.log('I love u!\n')`;
console.log(body);
// =>:
// "console.log('I love u!
// '))"



// Correct:
body = `console.log('I love u!\\n')`;
console.log(body);
// => "console.log('I love u!\n')"
```

现在，我们修改渲染器对转义字符进行逃逸，：

```js
// 需要逃逸的字符
const escapes = {
        "'": "'",
        '\\': '\\',
        '\r': 'r',
        '\n': 'n',
        '\u2028': 'u2028', // 行分隔符
        '\u2029': 'u2029' // 行结束符
};

// 逃逸正则
const escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

// 逃逸替换函数
function escape(match) {
    return '\\' + escapes[match]; 
}

function render(tpl, data) {
    // 拼接字符串
    let concating = `content +='`;
    let index = 0;
    tpl.replace(matcher, (match, interpolate, evaluate, offset) => {
        // 逃逸
        concating += tpl.slice(index, offset).replace(escapeRegExp, escape);
        // 刷新拼接起点
        index = offset + match.length;
        if(evaluate) {
            // 如果是执行逻辑
            concating += `';\n${evaluate}\n content +='`;
        } else if(interpolate) {
            // 如果是插值
            concating += `'+${interpolate}+'`;
        }
        return match;
    });
    // 剩余字符拼接
    concating += tpl.slice(index).replace(escapeRegExp, escape);;
    concating += `';\n`;
    concating = `with(obj) {\n${concating}}`;
    // 通过函数来支持逻辑执行
    const body = `let content = ''; \n${concating}; \nreturn content;`;
    const renderFunc = new Function('obj', body);
    return renderFunc(data);
}
```

### 优化：预编译提升性能

刚才我们实现的模板系统，仅只是一个简单的“替换性”模板，他最大的不足在于：

### underscore中的`_.template()`