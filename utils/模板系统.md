## 模板系统

### `_.noConflict()`： 将`_`对象的所有权交还

__源码__：

```js
_.noConflict = function () {
    // 回复原来的_指代的对象
    root._ = previousUnderscore;
    // 返回underscore对象
    return this;
};
```

假定在我们的工程中，已经**占据**了`_`对象，那么，之后我们引入underscore，`_`就会被underscore夺走：

```js
_ = {
    owner: 'wxj'
};

// 引入underscore后

console.log(_.owner); // => undefined
```

`_.noConflict`能够返回被underscore占据的`_`，并重新制定underscore对象：

```js
var underscore = _.noConflict();

console.log(_.owner); // => 'wxj'
```

### `_.identity(value)`：返回`value`本身

__源码__：

```js
_.identity = function (value) {
    return value;
};
```

很多没接触过FP编程的开发者看到这个方法会很诧异，要获得值本身的话，直接用`value`不就好，干嘛还有包一层函数？假定有这样一个情景，我们想要复制一个数组：

```js
var arr = [1,2,3,4,5];
var dstArr = arr.map((item, index) => {
    return item;
});
```

而借助于`_.identity`方法，我们可以这样做：

```js
var arr = [1,2,3,4,5];
var dstArr = arr.map(_.identity);
```