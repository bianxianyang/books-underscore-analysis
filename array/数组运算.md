## 数组运算
### `_.uniq`（别名：`_.unique`）：数组去重
__源码__：
```js
_.uniq = _.unique = function (array, isSorted, iteratee, context) {
    // 如果第二个参数不是bool, 则应当理解为是比较函数, 且默认是没有排序的数组
    if (!_.isBoolean(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = []; // 标识数组
    for (var i = 0, length = getLength(array); i < length; i++) {
        var value = array[i],
            computed = iteratee ? iteratee(value, i, array) : value;
        // 如果排好序了, 直接通过比较操作!==
        if (isSorted) {
            // 如果已经排序, seen只需要反映最近一次见到的元素
            // !i: 第一个元素放入结果数组
            // seen !== computed 没有见过的元素放入结果数组
            if (!i || seen !== computed) result.push(value);
            // 刷新最近一次所见
            seen = computed;
        } else if (iteratee) {
            // 如果尚未排序, 且存在比较函数, 亦即不能直接通过===判断
            // 那么我们无法直接通过_.contains(result, value)判断value是否已经存在
            // 例如_.unique([{age:13, name:"tom"},{age:15, name:"jack"},{age:13, name:"bob"}], 'age']
            // 这种情况下就需要借助于seen这个辅助数组存储计算后的数组元素
            if (!_.contains(seen, computed)) {
                seen.push(computed);
                result.push(value);
            }
        } else if (!_.contains(result, value)) {
            // 否则直接通过contains进行判断
            result.push(value);
        }
    }
    return result;
};
```
underscore提供了一个的数组去重功能十分健壮，他完成了如下优化：
- 通过指定`iteratee`， 让我们灵活定义“重复标准”，而不简单只是值比较(`===`)
- 通过指定`isSorted`，提高对排序后的数组去重性能

__用例__：
```js
// 一般去重
_.uniq([1,1,1,1,2,2,2,3,3]);
// => [1,2,3]

// 指定`iteratee`
_.unique([{age:13, name:"tom"},{age:15, name:"jack"},{age:13, name:"bob"}], 'age']
// => [{age:13, name:"tom"}, {age:15, name: "jack"}]

// 性能对比
var arr = [];
for(i=0;i<100000;i++) {
  arr.push(i);
  arr.push(i);
}

console.time("未声明已排序");
_.uniq(arr);
console.timeEnd("未声明已排序");
// => "未声明已排序: 72054.154ms"

console.time("声明已排序");
_.uniq(arr, true);
console.timeEnd("声明已排序");
// "声明已排序: 5.667ms"
```

### `_union`：求取数组并集
__源码__：
```js
// master
_.union = restArgs(function(arrays) {
  return _.uniq(flatten(arrays, true, true));
});

// 1.8.3

```
可以看到，在`master`分支上，`_.union`函数支持rest参数，由于rest参数最终会被处理成数组，所以，假定我们在调用`_.union`的时候传入两个数组`[1, 2, 3, [4, 5]]`和`[6, [7]]`，那么`arrays`实际上是：`[[1, 2, 3, [4, 5], [6, [7]]]`。所以，我们先要__浅展开__`arrays`，然后去重，即得到数组的并集。

__用例__：
```js
_.union([1, 2, 3, [4, 5]], [6, [7]]);
// => [1, 2, 3, [4, 5], 6, [7]]
```

### `_.intersection`：求取数组交集
__源码__：
```js
_.intersection = function(array) {
  var result = [];
  var argsLength = arguments.length;
  for (var i = 0, length = getLength(array); i < length; i++) {
    var item = array[i];
    if (_.contains(result, item)) continue;
    var j;
    // 
    for (j = 1; j < argsLength; j++) {
      if (!_.contains(arguments[j], item)) break;
    }
    if (j === argsLength) result.push(item);
  }
  return result;
};
```

数组交集的求取思路为：
- 遍历第一个数组的每个元素，在之后的所有数组中找寻是否有该元素，有则放入结果数组

__用例__：
```js
_.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
// => [1, 2]
```

### `_.difference`：求取数组差集
__源码__：
```js
// master
_.difference = restArgs(function(array, rest) {
  rest = flatten(rest, true, true);
  return _.filter(array, function(value){
    return !_.contains(rest, value);
  });
});
```

