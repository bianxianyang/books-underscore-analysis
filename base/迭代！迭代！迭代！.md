## 迭代！迭代！迭代
### 使用迭代，而不是循环
在函数式编程，更推荐使用__迭代__：

```js
var results = _.map([1,2,3],function(elem){
  return elem*2;
}); // => [2,4,6]
```

而不是__循环__：

```js
var results = [];
var elems = [1,2,3];
for(var i=0,length=elems.length;i<length;i++) {
  results.push(elems[i]);
} // => [2,4,6]
```

### iteratee

对于一个迭代来说，他至少由如下两个部分构成：

- 被迭代集合
- 当前迭代过程

在underscore中，当前迭代过程是一个函数，他被称为__iteratee__（直译为被迭代者）,他将对当前的迭代元素进行处理。我们看到__map__的实现：

```js
_.map = _.collect = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length); // 定长初始化数组
    for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
};

```

我们传递给的map的第二个参数就是一个iteratee，他可能是函数，对象，甚至是字符串，故而，underscore需要将其统一处理为一个函数。这个处理由underscore的内置函数（iternal function）__cb__来完成。下面我们看一下__cb__的实现：

```js
var cb = function (value, context, argCount) {
    // 是否用自定义的iteratee
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    // 针对不同的情况
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
};
```

cb根据不同情况来为我们的迭代创建一个迭代过程iteratee，服务于每轮迭代：
#### value is null
如果传入的value为null，亦即没有传入iteratee，则iteratee的行为只是返回当前迭代元素自身，比如
```js
var results = _.map([1,2,3]); // => results：[1,2,3]
```

#### value is a function
如果传入value是一个函数，那么通过内置函数__optimizeCb__对其进行优化，optimizeCb的作用放到之后讲，先来看个传入function的例子：
```js
var results = _.map([1,2,3],function(value,index,obj) {
  return '['+obj+']' + '\'s '+index+' position is '+value;
});
// => results:  [
//  "[1,2,3]'s 0 position is 1", 
//  "[1,2,3]'s 1 position is 2", 
//  "[1,2,3]'s 2 position is 3"
// ]
```

#### value is an object
如果value传入的是一个对象，那么返回的iteratee的目的是想要知道当前被迭代元素是否匹配给定的这个对象
```js
var results = _.map([{name:'yoyoyohamapi'},{name: 'wxj',age:13}], {name: 'wxj'});
// => results: [false,true]
```

#### value is a number， string or ...
如果以上情况都不是， 那么传入的value会是一个字面量（直接量），他代表一个对象属性名称（key），返回的iteratee将是__获得迭代元素特定属性的值__的函数：__property, 如：
```js
var results = _.map([{name:'yoyoyohamapi'},{name:'wxj'}],'name');
// => results: ['yoyoyohamapi', 'wxj'];
```

### 自定义iteratee
在__cb__函数的代码中，我们也发现了underscore支持通过覆盖其提供的__iteratee__函数来自定义iteratee，更确切的说，来自己决定如何产生一个iteratee：
```js
var cb = function (value, context, argCount) {
  // ...
  if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
  // ...
}
```

我们看一下__iteratee__函数的实现：

```js
_.iteratee = builtinIteratee = function (value, context) {
    return cb(value, context, Infinity);
};
```

默认的iteratee产生器仍然是把生产iteratee的工作交给__cb__完成，并且通过变量__buildIteratee__保存了你热不产生器的引用，方便之后我们覆盖了__\_.iteratee__后，underscore能够通过比较__\_.iteratee__与buildIteratee来知悉这次覆盖（也就知悉了用户想要自定义iteratee的生产过程）。

比如当传入的value是对象时，我们不想返回一个matcher来判断当前元素是否满足条件，而是就像返回当前元素自身（这么做很无聊），就可以这么做：

```js
_.iteratee = function(value, context) {
  // 现在，value为对象时，也是返回自身  
  if (value == null || _.isObject(value)) return _.identity;
  if (_.isFunction(value)) return optimizeCb(value, context, argCount);
  return _.property(value);
}
```

现在运行之前的例子，看一下有什么不同：

```js
var results = _.map([{name:'yoyoyohamapi'},{name: 'wxj',age:13}], {name: 'wxj'});
// => results: [{name:'yoyoyohamapi'}, {name: 'wxj', age```:13}];
```

> 重置默认的iteratee改变迭代过程中的行为只在underscore最新的master分支支持， 发布版的1.8.3并不支持， 我们可以看到发布版的1.8.3中的cb代码如下：
 ```js
var cb = function (value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
};
```

### optimizeCb
在cb(value, context, argCount)中，我们知道，当传入的value是一个函数时，value还要经过一个叫__optimizeCb__的内置函数才能获得最终的iteratee：

```js
var cb = function (value, context, argCount) {
  // ...
  if (_.isFunction(value)) return optimizeCb(value, context, argCount);
  // ...
};
```

顾名思义， optimizeCb有优化回调的意思，所以他是一个对最终返回的iteratee进行优化的过程，我们看到他的源码：

```js
/** 优化回调(特指函数中传入的回调)
 *
 * @param func 待优化回调函数
 * @param context 执行上下文
 * @param argCount 参数个数
 * @returns {function}
 */
var optimizeCb = function(func, context, argCount) {
  // 一定要保证回调的执行上下文存在
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1: return function(value) {
      return func.call(context, value);
    };
    case 2: return function(value, other) {
      return func.call(context, value, other);
    };
    case 3: return function(value, index, collection) {
      return func.call(context, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(context, accumulator, value, index, collection);
    };
  }
  return function() {
    return func.apply(context, arguments);
  };
};
```

optimizeCb的总体思路就是，传入待优化的回调函数func， 以及迭代回调需要的参数个数argCount，分情况进行优化：

#### argCount == 1
若argCount为1，则迭代回调只需要1个参数：
在underscore的__times__函数的实现中，就是给argCount传入了1：
```js
// 执行iteratee函数n次，返回每次执行结果构成的数组
_.times = function (n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
};
```
对于times中的iteratee来说，他只需要一个参数，就是当前执行索引，比如times中，将当前的执行索引传给了iteratee，看一个times的使用例子:
```js
function getIndex(index) {
  return index;
}
var results = _.times(3, getIndex); // => [0,1,2]
```

#### argCount == 2
若argCount为2，则返回的迭代回调需要两个参数，由于这个case在underscore中没用使用，所以最新的master分支已经不再考虑这个case。

#### argCount == 3
若argCount为3（默认情况，当没有给argCount显式赋值时），则迭代回调需要3个参数，通常是：
  - value：当前迭代元素的值
  - index：迭代索引
  - collection：被迭代集合

在map, each, filter等函数中，都是给argCount赋值了3：
```js
_.each([1,2,3], function(value,index,collection) {
  console.log("被迭代的集合："+collection+"；迭代索引："+index+"；当前迭代的元素值："+value);
});
// => 
// 被迭代的集合：1,2,3；迭代索引：0；当前迭代的元素值：1
// 被迭代的集合：1,2,3；迭代索引：1；当前迭代的元素值：2
// 被迭代的集合：1,2,3；迭代索引：2；当前迭代的元素值：3
```

#### argCount == 4
若argCount为4，则返回的iteratee需要四个参数，分别是:
  - accumulator：累加器
  - value：迭代元素
  - index：迭代索引
  - collection：当前迭代集合
那么这个累加器是什么意思呢？我们可以看一下underscore中的内部函数__createReducer__，他是用来生成reduce函数的工厂函数，underscore中的reducer及reduceRight都是由他创建的：

```js
/**
 * reduce函数的工厂函数, 用于生成一个reducer, 通过参数决定reduce的方向
 * @param dir 方向 left or right
 * @returns {function}
 */
var createReduce = function (dir) {
    var reducer = function (obj, iteratee, memo, initial) {
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            index = dir > 0 ? 0 : length - 1;
        // memo用来记录最新的reduce结果
        // 如果reduce没有初始化memo, 则默认为首个元素(从左开始则为第一个元素,从右则为最后一个元素)
        if (!initial) {
            memo = obj[keys ? keys[index] : index];
            index += dir;
        }
        for (; index >= 0 && index < length; index += dir) {
            var currentKey = keys ? keys[index] : index;
            // 执行reduce回调,刷新当前值
            memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
    };

    return function (obj, iteratee, memo, context) {
        // 如果参数正常,则代表已经初始化了memo
        var initial = arguments.length >= 3;
        // reducer因为引入了累加器,所以优化函数的第三个参数传入了4,
        // 这样, 新的迭代回调第一个参数就是当前的累加结果
        return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
};
```
我们可以看到，createReduce最终创建的reducer就是需要一个累加器，该累加器需要被初始化，看一个利用reduce函数求和的例子：
```js
var sum = _.reduce([1,2,3,4,5], function(accumulator, value, index, collection){
  return accumulator+value；
},0); // => 15;
```