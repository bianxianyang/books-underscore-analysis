### 无类
对于熟悉面向对象的同学，比如说是java开发者，一开始接触到javascript会非常懊恼，因为在javascript中，是没有类的概念的，即便es6引入了`class`，`extends`等关键字，那也只是语法糖（syntax sugar），而不能让我们真正创建一个类。我们知道，类的作用就在于`继承`和`派生`。作为面向对象的三大特征之一的继承，其优劣在此不再赘述，下面我们看一下如何在缺乏类支持的javascript实现继承。

### 原型继承
我们说A继承子B，实际上可以转义为`is-a（什么是什么）`关系：
> A是B，比如Student继承自Person，Student是一个Person，只不过比Person更加具体

换言之，继承描述了一种层次关系，或者说是一种递进关系，一种更加具体化的递进过程。所以，继承也不真正需要“类”来支撑，他只需要这个递进关系。

js中虽然没有类，但是是有对象的概念，我们仍然可以借用对象来描述这个递进关系，只不过js换了一种描述方式，叫做`原型（prototype）继承`。顾名思义，原型描述了一个对象的来由：

> 原型 ----> 对象

显然，二者就构成了上面我们提到的继承（层次递进）关系，在js中，原型和对象间的联系链条是通过对象的`proto`属性来完成的。举个更具体的例子，学生对象（student）的原型是人（person），因为学生源于人，在js中我们可以这样实现二者的继承关系：

```js
var person = {
  name: '',
  eat: function() {
    console.log("吃饭");
  }
};

var student = {
  name: 'wxj',
  learn: function() {
    console.log("学习");
  }
};
student.__proto__ = person;
// 由于student is a person，所以他也能够eat
student.eat();
```

### new运算符
上面例子的继承虽然达到了目的，但是还不是我们熟悉的传统的面向对象的继承的写法，好在js还提供了`构造函数（constructor）`，`new`运算符和`prototype`属性，我们看一下如何通过这三者重写上面的继承:

```js
// 声明一个叫Person的构造函数，为了让他更像是一个类，我们将其大写
function Person(name) {
  this.name = name;
}
// 通过函数的prototype属性，我们声明了Person的原型，并且可以在该原型上挂载我们想要的属性或者方法
Person.prototype.eat = function() {
  console.log(this.name+"在吃饭");
}
// 现在让student来继承person
var student = new Person("wxj");
student.name; //=>"wxj"
student.eat(); // "wxj在吃饭"
// 扩展
student.learn = function() {
  console.log(this.name+"在学习");
}
student.learn(); // "wxj在学习"
```

`new`运算符实际上是自动为我们解决了如下几件事:
1. 构造出student于person间的关系链，即
```js
var student = {'__proto__': Person.prototype};
```
2. 调用`Person`构造方法,并且将上下文（this）绑定到student上, 通过Person构造student：
```js
Person.apply(student, arguments);
```

3. 设置student的`constructor`属性为Person，以便追溯。最后返回创建的对象:
```js
student.constructor = Person;
return student;
```

有了这些知识，我们不难模拟出一个`new`方法来实现对象的创建:
```js
function newObj(constructor) {
  var n = {
    '__proto__':constructor.prototype
    'constructor': constructor
  };
  return function() {
    constructor.apply(n,arguments);
    return n;
  }
}
// 测试
function Person(name) {
  this.name = name;
}

Person.prototype.eat = function() {
  console.log(this.name+"在吃饭");
}
var student = newObj(Person)("wxj");
student.name; //=>"wxj"
student.eat(); // "wxj在吃饭"
student.learn = function() {
  console.log(this.name+"在学习");
}
student.learn(); // "wxj在学习"
```

### Object.create
另外，ES5更为我们提供了新的对象创建方式:
```js
Object.create(proto, [ propertiesObject ])
```

现在，我们可以这样创建一个继承自proto的对象：
```js
function Person(name) {
  this.name = name;
}

Person.prototype.eat = function() {
  console.log(this.name+"在吃饭");
}

var student = Object.create(Person.prototype);
student.eat(); // "undefined在吃饭"
student.name = 'wxj';
student.eat(); // "wxj在吃饭"
```

在构造对象上，`Object.create(proto)`的过程如下：

1. 创建一个临时的构造函数，并将其原型指向proto：
```js
var Temp = function() {};
Temp.prototype = proto;
```

2. 通过`new`新建对象，该对象由这个临时的构造函数构造：
```js
var obj = new Temp();
```

3. 清空临时构造函数的原型，并返回创建的对象
```js
Temp.prototype = null;
return obj;
```

### 为什么要用Object.create()
如此看来，`Object.create`似乎也只是`new`的一次包裹，并无任何优势可言，但是，正式这次包裹，是我们新建对象更加灵活。使用`new`运算符最大的限制条件是--被`new`运算的只能是一个`构造函数`，如果你想由一个普通对象构造新的对象，使用new就将会报错:
```js
var person = {
  name:'',
  eat: function() {
    console.log(this.name+"在吃饭");
  } 
};

var student  = new person;
// =>"Uncaught TypeError: person is not a constructor(…)"
```

但是`Object.create`就不依赖构造函数，因为在上面对其工作流程的介绍中，我们知道，`Object.create`内部已经维护了一个构造函数，并将该构造函数的`prototype`属性指向传入的对象，因此，他比`new`更加灵活：
```js
var student = Object.create(person);
student.name = "wxj";
student.eat(); // 'wxj在吃饭'
```

另外，`Object.create`还能传递第二参数，该参数是一个属性列表，能够初始化或者添加新对象的属性，则更加丰富了创建的对象时的灵活性和扩展性：
```js
var student = Object.create(person,{
  name: {value:'wxj'，writable: false}
});
student.name = "yoyoyo";
student.eat(); // "wxj在吃饭"
```

> 更多用例参看[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

### underscore是如何创建对象的
下面我们来看看underscore是怎样创建对象的：
```js
var nativeCreate = Object.create;

// ...

// Ctor: 亦即constructor的缩写，这个空的构造函数将在之后广泛用于对象创建,
// 这个做法是出于性能上的考虑，避免多次创建空的构造函数
var Ctor = function () {};

// ....

/**
 * 创建一个对象，该对象继承自prototype
 * 并且保证该对象在其原型上挂载属性不会影响所继承的prototype
 * @param {object} prototype
 */
var baseCreate = function (prototype) {
    if (!_.isObject(prototype)) return {};
    // 如果存在原生的创建方法（Object.create），则用原生的进行创建
    if (nativeCreate) return nativeCreate(prototype);
    // 利用Ctor这个空函数，临时设置对象原型
    Ctor.prototype = prototype;
    // 创建对象，result.__proto__ === prototype
    var result = new Ctor;
    // 还原Ctor原型
    Ctor.prototype = null;
    return result;
};
```
我们可以看到，underscore利用`baseCreate`创建对象的时候会先检查当前环境是否已经支持了`Object.create`,如果不支持，会创建一个简易的polyfill：
```js
// 利用Ctor这个空函数，临时设置对象原型
Ctor.prototype = prototype;
// 创建对象，result.__proto__ === prototype
var result = new Ctor;
// 还原Ctor原型
Ctor.prototype = null;
```

而之所以叫`baseCreate`，也是因为其只做了原型继承，而不像`Object.create`那样还支持传递属性列表。

### ES6中的class语法糖
在ES6中，支持了class和extends关键字，让我们在撰写类和继承的时候更加靠近java等语言的写法：
```js
class Person {
  constructor(name){
    this.name=name;
  }
  
  eat() {
    console.log(this.name+'在吃饭');
  }
}

class Student extends Person{
  constructor(name){
    super(name);
  }
  
  learn(){
    console.log(this.name+"在学习");
  }
}
// 测试
var student = new Student("wxj");
student.eat(); // "wxj在吃饭" 
student.learn(); // "wxj在学习"
```

但要注意，这只是语法糖，es6并没有真正实现类的概念， 不信我们看下Babel(一款流行的es6编译器)对上面程序的编译结果，当中我们能看到如下语句：
```js
Object.defineProperty(target, descriptor.key, descriptor)；
Object.create();
```
可见，class的实现还是依赖于ES5提供的`Object.defineProperty`和`Object.create`方法。

### 参考资料
- [MDN 继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
- [Javascript – How Prototypal Inheritance really works](http://blog.vjeux.com/2011/javascript/how-prototypal-inheritance-really-works.html)
- [JavaScript中的类继承](http://javascript.crockford.com/zh/inheritance.html)
- [MDN Object.create](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)