## 查询
这里提到的查询主要是指完成如下意图的查询:
1. 根据给定元素，查询元素所在位置
2. 根据一定条件，获得元素

针对目的1，underscore提供了以下API：
- `_.indexOf`
- `_.lastIndexOf`
- `_.sortedIndex`

> `_.indexOf`及`_.lastIndexOf`只支持对于数组元素的搜索。

针对目的2，underscore提供了一些api：
- `_.find`(别名：`_.detect`)
- ``
- ``：

### `createdIndexFinder`
undersocre中通过内置的工厂函数`createIndexFinder()`来创建一个索引查询器，`_.indexOf`及`_.lastIndexOf`正是由该函数所创建的。

`createIndexFinder()`接受三个参数：
- `dir`：查询方向，`_.indexOf`即是正向查询， `_.lastIndexOf`即是反向查询。
- `predicateFind`：真值检测函数，该函数只有在查询元素不是数字（`NaN`）才会使用。
- `sortedIndex`：有序数组的索引获得函数。这个参数很有意思，如果设置了该参数，将假定数组已经有序，从而更加高效的通过针对有序数组的查询函数（比如二分查找等）来优化查询性能。

```js
var createIndexFinder = function (dir, predicateFind, sortedIndex) {
    return function (array, item, idx) {
        var i = 0, length = getLength(array);
        // 如果设定了查询起点, 且查询起点格式正确(数字)
        if (typeof idx == 'number') {
            // 校正查询起点
            if (dir > 0) {
                i = idx >= 0 ? idx : Math.max(idx + length, i);
            } else {
                length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
            }
        } else if (sortedIndex && idx && length) {
            // 如果传递sortedIndex函数, 则先假设array为排序好的, 获得item在array中的位置
            idx = sortedIndex(array, item);
            // 验证这个假设是否正确
            return array[idx] === item ? idx : -1;
        }
        // 如果待查找item不是数字，是NaN(JS中,NaN===NaN 为false), 需要通过predicateFind来查找
        if (item !== item) {
            idx = predicateFind(slice.call(array, i, length), _.isNaN);
            return idx >= 0 ? idx + i : -1;
        }
        // 否则直接通过 === 进行查找
        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
            if (array[idx] === item) return idx;
        }
        return -1;
    };
};
```

`createIndexFinder`将会返回一个索引查询器，该索引查询器支持三个参数:
- `array`：待搜索数组
- `item`：待搜索对象
- `idx`： 查询起点，从数组的哪个位置开始查找。如果以数字的方式设置了查询起点，或者未设置查询起点，则无法使用`sortedIndex`方法进行查询优化。通常，我们可以设置该值为语义更加明显的`true`（代表启用查询优化）来对有序数组进行查询优化。

#### `_.indexOf`： 获得查询元素的索引，从头开始查找
__源码__：
```js
 _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
```

值得一提的是，`_.indexOf`方法的创建过程中被传递了`_.findIndex`作为元素的真值预测函数，以及`_.sortedIndex`作为当数组有序时获得索引的方式。这两个函数将在之后介绍。

__用例__：
```js
// 创建一个有序的大容量数组
var array = [];
for(var i=0;i < 1000000;i++) {
  array[i] = i;
}

console.time("以数字方式设置了查询起点，搜索耗时");
_.indexOf(array,500000);
console.timeEnd("以数字方式设置了查询起，搜索耗时");
// 以数字方式设置了查询起，搜索耗时：1.561ms

console.time("以非数字方式设置了查询起点，搜索耗时");
_.indexOf(array,500000, true);
console.timeEnd("以非数字方式设置了查询起点，搜索耗时");
// 以非数字方式设置了查询起点，搜索耗时：0.308ms
```

可以看到，经`_.sortedIndex`优化后的`_.indexOf`搜索性能更高。

#### `_.lastIndexOf`：获得待查询元素的索引，从数组末尾开始查找
__源码__：
```js
 _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
```

__用例__：
```js
_.lastIndexOf([1,2,3,1,2,3], 2);
// => 4
```

> 注意，这些查找的索引的函数的都是__非贪婪__的，一旦查找到，立即返回索引并停止查找。

#### _.sortedIndex：对已排序的集合进行查找，获得对应元素的位置
__源码__：
```js
_.sortedIndex = function (array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
};
```

> `_.sortedIndex`使用了[二分查找](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)作为查找算法。

__用例__：
```js
_.sortedIndex([10, 20, 30, 40, 50], 20); // => 1 

// `_.sortedIndex` 有可能返回”错误“的结果, 或者也可以理解为如果查找的元素不存在，将返回他应当存在的位置
_.sortedIndex([10, 20, 30, 40, 50], 35); // => 3 

// `_.sortedIndex`也支持对对象集合的搜索。
```
_.sortedIndex([{name: 'wxj'}, {name: 'lx'}, {name: 'lcx'}, {name: 'wxj'}]);
// => 0
```

#### _.indexOf

### 获得元素