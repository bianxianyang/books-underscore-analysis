## 随机取样与洗牌算法
### 洗牌算法
在一些场景下，我们需要抽样一个序列的部分，一般来说，我们会需要抽样过程是随机的，假定样本容量为$$N$$，序列下标为$$0...M$$，且$$N \leq M$$，那么我们这样完成抽样过程
1. 随机生成$$N$$个序号
2. 根据序号，逐个从序列中取出元素

可以看到，过程很简单，唯一需要被设计的地方就是__如何均匀地生成随机序号__，这样才有助于我们获得一个高质量的样本。

不过，一般的随机数生成算法可能会有随机数分布不均匀的问题，所以，单纯地生成$$N$$个随机位置后取出的样本可能也不会太均匀。通常，我们还要额外地多一些努力：__每次获得随机位置后，再乱序序列__。这就是最常见的乱序数组的算法--[洗牌算法](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)。

算法的思路在宏观上可以概括为：将集合视为牌堆，不停地从牌堆中抽牌直至牌堆变空，所抽的拍构成了新的牌堆，也就是乱序后的集合:

```js
// 洗牌算法
function shuffle(set, n) {
  var length = set.length;
  var i;
  // 初始化sample
  var sample = set.map(function(elem){
    return elem;
  });
  // 最后一个元素的位置
  var last = length - 1;
  // 洗到第n个就可以停止
  for(i=0; i<n; i++) {
    // 从剩余未乱序的集合中选出一个随机位置
    var randIndex = Math.floor(Math.random()*(last-i+1)+i);
    // 交换随机位置上与当前位置的值，完成乱序
    var tmp = sample[i];
    sample[i] = sample[randIndex];
    sample[randIndex] = tmp;
  }
  // 返回前n个样本
  return sample.slice(0, n);
}

// 测试
var set = [1,2,3,4,5,7,8,9,10];

var newSet = shuffle(set4);
// => 
```

### `_.sample`
