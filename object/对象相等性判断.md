## 对象相等性判断



### 原生js的比较问题

在原生js中，在判断`a`与`b`的相等性时，面临如下的比较问题：

* `0 === -0`
* `null == undefined`
* `NaN != NaN`
* `NaN !== NaN`

`0 === -0`:

对于该问题，我们可以借助如下等式解决：

```js
1/0 === 1/0
1/-0 !== 1/0
```

`null == undefined`:

对于该问题，我们可以通过如下等式解决：

```js
null === null;
null !== undefined;
```

`NaN != NaN` 及 `NaN !== NaN`：

如果我们要认为NaN等于NaN（这更加符合认知和语义），我们只需要：

```js
if(a !== a) 
    return b !== b;
```

### `_.isEqual(a,b)`：判断`a`，`b`是否相等

在underscore中提供了该函数用于判断两个变量是否相等，其源码如下：

```js
_.isEqual = function (a, b) {
    return eq(a, b);
};
```

其内部是通过`eq`函数实现的：

```js
eq = function (a, b, aStack, bStack) 
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    if (a == null || b == null) return a === b;
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    // 如果a,b是function获得object（数组也是object）则意味着二者需要深度比较
    return deepEq(a, b, aStack, bStack);
};
```

在`eq`的源码中，我们也发现，当`a`，`b`是数组或者对象时，会调用`deepEq`进行深度比较

### 深度比较

对于如下几个类型（通过`Object.prototype.toString()`取到），需要进行深度比较：

- `[object RegExp]`：正则表达式
- `[object String]`：字符串
- `[object Number]`：数字
- `[object Date]`：日期
- `[object Boolean]`：Bool值
- `[object Symbol]`：Symbol

这些类型的比较方式在`deepEq`中源码中可以轻松的理解：

```js
deepEq = function(a, b, aStack, bStack) {

// ...
    
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
        case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN.
            if (+a !== +a) return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            // var a = new Date();
            // +a; // => 1464867835038
            return +a === +b;
        case '[object Symbol]':
            return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }
    
// ...

}
```




