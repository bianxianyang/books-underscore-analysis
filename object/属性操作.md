## 属性操作
### `_.has(obj, key)`：判断`obj`是否具有某个属性`key`
该函数依赖于js原生的`Object.prototype.hasOwnProperty`，因而他判断的是自身的属性，而不会去寻找原型链上的属性：
```js
_.has = function(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}
```

__用例__：
```js
var foo = new Object();
foo.bar = 'bar';
_.has(foo, 'bar'); // => true
_.has(foo, 'toString'); // => false
```

### `_.keys(obj)`：获得`obj`的所有属性，仅包括自有属性
__源码__：
```js
_.keys = function (obj) {
  if (!_.isObject(obj)) return [];
  // 如果原生的Object.keys方法存在的话，
  // 直接调用Object.keys来获得自有属性
  if (nativeKeys) return nativeKeys(obj);
  var keys = [];
  // 通过_.has,剔除掉非自有属性
  for (var key in obj) if (_.has(obj, key)) keys.push(key);
  // IE9之前存在枚举bug，需要校正最后的属性集合
  if (hasEnumBug) collectNonEnumProps(obj, keys);
  return keys;
};
```

如果支持ES5的`Object.keys`，则用该方法获得对象的属性，否则通过`for in`来取得对象的key，再获得对象key集合之后，需要判断key集合是否应当修复，因为在IE9之前的版本，存在一个bug，一些key不能被`for key in ...`所迭代：
```js
var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
```

该bug下不能被`for..in`迭代的key有：
```js
var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
        'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
```

### `_.allKeys(obj)`：获得`obj`的所用属性
__源码__：
```js
_.allKeys = function (obj) {
  if (!_.isObject(obj)) return [];
  var keys = [];
  for (var key in obj) keys.push(key);
  // Ahem, IE < 9.
  if (hasEnumBug) collectNonEnumProps(obj, keys);
  return keys;
};
```

__用例__：
```js
function Person(name) {
  this.name = name;
}

Person.prototype.say = function() {
  console.log('hello');
}

var wxj = new Person('wxj');
_.keys(wxj);
// => ['name']

_.allKeys(wxj);
// => ['name', 'say']

```

### `_.values(obj)`：获得`obj`的值集合
__源码__：
```js
_.values = function (obj) {
  // 很简单，遍历key集合，取到对应的value
  var keys = _.keys(obj);
  var length = keys.length;
  // 定长初始化,提前分配内存空间
  var values = Array(length);
  for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
  }
  return values;
};
```

__用例__：
```js
_.values({one: 1, two: 2, three: 3});
// => [1, 2, 3]
```