## 类型判断
underscore中提供了多个`isXXX`方法用以判断对象属于哪种“类型”。
### 常规判断
大部分元素都可以通过`Object.prototype.toString`的结果进行判断，比如：
```js
var string = new String('wxj');
Object.prototype.toString.call(string); // => '[object String]'
```

所以，对于如下类型，underscore皆是通过`Object.prototype.toString`来进行类型判断：
`Arguments`, `Function`, `String`, `Number`, `Date`, `RegExp`, `Error`, `Symbol`, `Map`, `WeakMap`, `Set`, `WeakSet`：
```js
_.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function (name) {
  _['is' + name] = function (obj) {
      return toString.call(obj) === '[object ' + name + ']';
  };
});
```

#### 修正`_.isArguments(obj)`
对于`Arguments`判断，IE9以前的版本，`Object.prototype.toString`返回的会是`'[object Object]'`而不是`'[object Arguments]`，需要通过判断对象是否具有`callee`来确定其是否`Arguments`类型，underscore对此进行了修正：
```js
if (!_.isArguments(arguments)) {
  // 判断obj是否是argumens
  // 只有arguments才会有callee属性
  _.isArguments = function (obj) {
      return _.has(obj, 'callee');
  };
}
```

#### 修正`_.isFunction(obj)`
此外，underscore还修正了在早起V8引擎下的对于对象是否为函数的判断：
```js
var nodelist = root.document && root.document.childNodes;
if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
  _.isFunction = function (obj) {
      return typeof obj == 'function' || false;
  };
}
```

### `_.isElement(obj)`：判断`obj`是否是DOM元素
### `_.isArray(obj)`：判断`obj`是否是数组
### `_.isObject(obj)`：判断`obj`是否是对象
### `_.isFinite(obj)`：判断`obj`是否有限
### `_.isNaN(obj)`：判断`obj`是否是一个NaN
### `_.isBoolean`：判断`obj`是否是布尔类型
### `_.isNull`：判断`obj`是否是null
### `_.isUndefined`：判断`obj`是否是undefined



