## 克隆与扩展
### 扩展
underscore中提供了两个方法用于对象属性的扩展：
- `_.extend(obj1, obj2, ...)`
- `_.extendOwn(obj1, obj2, ...)`
这两个函数都是由内部函数`createAssigner`进行创建的。
#### `createAssigner(keysFunc, defaults)`: 创建一个属性分配器，指定`keysFunc`作为获得对象属性的方式，指定`defaults`来声明是否要覆盖属性
```js
var createAssigner = function (keysFunc, defaults) {
    return function (obj) {
        // 参数的长度反映了传入对象的个数
        var length = arguments.length;
        if (defaults) obj = Object(obj);
        if (length < 2 || obj == null) return obj;
        // 遍历每个对象，从中不断获得属性，赋给obj
        for (var index = 1; index < length; index++) {
            var source = arguments[index],
                keys = keysFunc(source),
                l = keys.length;
            for (var i = 0; i < l; i++) {
                var key = keys[i];
                // 如果不是defaults模式，则会覆盖原来key的value
                // 如果是defaults模式，则只会设置原来为undefined的属性
                if (!defaults || obj[key] === void 0) obj[key] = source[key];
            }
        }
        return obj;
    };
};
```

#### `.extend(obj1, obj2, obj3....)`: `obj1`将继承`obj2`, `obj3`及后续传入对象的属性，包括他们原型链上的属性
__源码__：
```js
// _.allKeys会获得对象自身及其原型链上的所有属性
_.extends = createAssigner(_.allKeys)
```

__用例__：
```js
var student = {
    name: 'yoyoyohamapi',
    age: 13,
    sex: 'girl'
};
function Hobby(){
    this.hobby = "soccer";
}
Hobby.prototype.hate = "volleyball";
_.extend(student, new Hobby(),{sex:'boy'});
// => student: {
//    name: "yoyoyohamapi",
//    age: 13,
//    hobby: "soccer",
//    hate: "volleyball", // 原型链上的属性也被继承了
//    sex: "boy" // 会覆盖属性
//}
```

#### `.extendOwn(obj1, obj2, obj3....)`，别名：`_.assign`: `obj1`将继承`obj2`, `obj3`及后续传入对象的属性，但不包括他们原型链上的属性
__源码__：
```js
// _.keys只会获得自身属性
_.extendOwn = _.assign = createAssigner(_.keys);
```

__用例__：
```js
var student = {
    name: "yoyoyohamapi",
    age: 13,
    sex: 'girl'
};
function Hobby(){
    this.hobby = "soccer";
}
Hobby.prototype.hate = "volleyball";
_.extend(student, new Hobby(),{sex:'boy'});
// => student: {
//    name: "yoyoyohamapi",
//    age: 13,
//    hobby: "soccer", 
//    sex: "boy" // 会存在属性覆盖
//}
```

#### `_.defaults(obj, options...)`：用指定的属性覆盖`obj`中undefined属性，该函数在设置默认配置时非常有用
__源码__：
```js
_.defaults = createAssigner(_.allKeys, true);
```

__用例__：
```js
var defaultOptions = {
  method: 'GET',
  'content-type': 'application/json',
  accept: 'application/json'
};

var options = {
  method: 'POST'
};

var opts = _.defaults(options, defaultOptions);
// opts => {
//   method: 'POST',
//   'content-type': 'application/json',
//   accept: 'application/json'
//}
```

#### `Object.assign(...objs)`：ES2015中提供的对象扩展方法
通过MDN上的polyfill看出，`Object.assign`在扩展对象属性的时候，不会拷贝原型链上的属性
```js
if (typeof Object.assign != 'function') {
  Object.assign = function(target) {
    'use strict';
    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    target = Object(target);
    for (var index = 1; index < arguments.length; index++) {
      var source = arguments[index];
      if (source != null) {
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
    }
    return target;
  };
}
```

### 克隆
#### `_.clone(obj)`：克隆（浅）一个对象
underscore提供的克隆是浅克隆，亦即，对象中的数组、对象属性引用不会发生变变化：
```js
_.clone = function (obj) {
    if (!_.isObject(obj)) return obj;
    // 可以看出，如果obj是一个对象，那么该函数基于_.extend实现
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
};
```

__用例__：
```js
var family = {
  name: '304',
  dad: {
    name: 'wxj',
    age: 32
  }
}

var cloned = _.clone(family);

// 克隆是浅克隆
cloned.dad === family.dad; // => true
family.dad.name = 'john';
cloned.dad.name; // => 'john'
```

#### 深度克隆
underscore并没用提供深度克隆的方法，不过借助于递归，我们很容易构造一个__深度克隆__的方法：
```js
var deepClone = function(obj) {
  // 如果待克隆对象是数组
  if(_.isArray(obj)) {
      return _.map(obj, function(elem){
        return _.isArray(elem) || _.isObject(elem) ? deepClone(elem) : elem;
      });
  } else if(_.isObject(obj)){
      return _.reduce(obj, function(newObj, value, key){
        newObj[key] = _.isArray(value) || _.isObject(value) ? deepClone(value) : value;
        return newObj;
      }, {});
  } else {
    return obj;
  }
}
```

__测试__：
```js
var family = {
  name: '304',
  dad: {
    name: 'wxj',
    age: 32
  }
}

var cloned = _.clone(family);

// 克隆是浅克隆
cloned.dad === family.dad; // => false
family.dad.name = 'john';
cloned.dad.name; // => 'wxj'
```

深度克隆并非那么容易实现的，他包含有太多语义界定和边界用例，详情可以参看知乎上的这篇讨论：[
JavaScript 如何完整实现深度Clone对象？](https://www.zhihu.com/question/47746441)
