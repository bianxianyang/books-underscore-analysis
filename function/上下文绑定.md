## 上下文绑定

### 恼人的`this`
对于js初学者来说，`this`关键字一直是一个恼人的东西，关于`this`的解释和描述，最好的文章是[You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)下的[*this & Object Prototypes*章节](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)。在该文中，作者认为，人们通常会因为`this`的字面意思而产生如下两种误解

#### itself
把`this`理解为itself，也就是认为`this`指向了其所在的函数：
```js
function foo(num) {
    console.log( "foo: " + num );

    // keep track of how many times `foo` is called
    this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
    if (i > 5) {
        foo( i );
    }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( foo.count ); // 0 -- WTF?
```
当我们认为`this`指代的是所在函数`foo`时，就想要最后打印`foo.count`的结果是10，然而事与愿违。不过这种误解也是情有可原的，因为在js中，函数也是对象，而在对象中，__似乎__`this`确是指向了自身itself：
```js
var obj = {
  count : 10;
  foo: function(){
    console.log(this.count);
  }
}

obj.foo(); // => 10
```


### `this`究竟是谁？
`this`关键字并不神秘，我们需要知道，`this`指代的对象并不能在函数定义就确定，他由__*函数执行时所在的上下文*__确定。

### 调用时绑定

### 定义时绑定
在ES5中，已经提供了`Function.prototype.bind`来完成上下文的绑定：
```js
function showName() {
  console.log('my name is:'+this.name);
}

var student = {
  name: 'wxj',
  age: 13
};

var showWxjName = showName.bind(student);
showWxjName();
// => "my name is:wxj"
```

### underscore提供的bind
underscore中也提供了绑定函数上下文的方法`_.bind`和`_.bindAll`
