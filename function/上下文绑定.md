##上下文绑定

### 恼人的`this`
对于js初学者来说，`this`关键字一直是一个恼人的东西，关于`this`的解释和描述，最好的文章是[You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)下的[*this & Object Prototypes*章节](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)。在该文中，作者认为，人们通常会因为`this`的字面意思而产生如下两种误解

#### itself
把`this`理解为itself，也就是认为`this`指向了其所在的函数：
```js
function foo(num) {
    console.log( "foo: " + num );

    // keep track of how many times `foo` is called
    this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
    if (i > 5) {
        foo( i );
    }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// how many times was `foo` called?
console.log( foo.count ); // 0 -- WTF?
```
当我们认为`this`指代的是所在函数`foo`时，就想要最后打印`foo.count`的结果是10，然而事与愿违。不过这种误解也是情有可原的，因为在js中，函数也是对象，而在对象中，__似乎__`this`确是指向了自身itself：
```js
var obj = {
  count : 10;
  foo: function(){
    console.log(this.count);
  }
}

obj.foo(); // => 10
```

#### its scope
还有一种误解显得“高明”许多，他们认为`this`由其函数所在的词法作用域决定，比如下例：
```js
function foo() {
    var a = 2;
    this.bar();
}

function bar() {
    console.log('a is:'+ this.a );
}

foo(); //a is:undefined
```
这个例子非常有意思，他不只犯了一个错误：
- 首先，代码书写者认为`this`由其函数所在的词法作用域决定，函数`foo`所在的词法作用域是在全局作用域，所以`this`就指向了全局作用域，那么，由于函数`bar`所在的词法作用域也是全局作用域，`this.bar()`理应能够工作。事实也确实如此，但是工作的原因却并非如此，之后会做解释。
- 代码书写者认为`this`也能像闭包那样被使用：当内部作用域中`this.a`寻找失败时，会去外部作用于寻找`this.a`。千万要记住，`this`并不具备__*跨作用域*__的能力。

### `this`究竟是谁？
`this`关键字并不神秘，我们需要知道，`this`指代的对象并不能在函数定义就确定，他由__*函数执行时所在的上下文*__确定。换言之，一个函数如果不跑起来，他内部的`this`就永远无法确定。看到如下代码：
```js
function foo() {
  console.log(this.a);
}

var a = 2;
foo(); // => 2
```

当函数`foo`调用时，亦即`foo()`语句执行时，其所在的__上下文__是全局对象，所以，`this`绑定到了全局对象（在浏览器环境的话就是`window`对象）。这个例子还是会让人以为`this`指向了其函数所在的词法作用域，那么再看下面的一个代码：
```js
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo
}

obj.foo(); // => 2
```
当成员方法`obj.foo`被调用时，以及`obj.foo()`语句执行时，函数`foo`所在的执行上下文变成了`obj`，即`this`指向了`obj`。

综上，我们知道，想要知道`this`最终“情归何处”，就一定是在__运行时（runtime）__环境，而不是函数定义时。但是，js同样为我们提供了手段，来手动绑定函数中的`this`关键字，我将他分为两类：
1. 调用型绑定：进行一次函数调用，并绑定当中的`this`
2. 定义型绑定：不进行函数调用，新创建一个函数，指定其中的`this`归属 

> 注意，这两型的绑定都不会改变*`this`只有在运行时才能够绑定*这一事实。

### 调用型绑定
在`Function.prototype`上，提供了`apply`和`call`两个方法来绑定`this`指代的上下文对象，二者的第一个参数都是待绑定对象，而第二个参数都是调用参数，表现形式不同，`apply`传递的参数是__数组型__的，`call`则是__逐个传递参数__：
```js
function add(a, b) {
  var result = a+b;
  console.log(this.name+" wanna get result:"+result);
}

var caller1 = {
  name: 'wxj'
};

var caller2 = {
  name: 'zxy'
};

add.call(caller1, 3, 4);
// => "wxj wanna get result:7"

add.apply(caller2, [3,4]);
// => "zxy wanna get result:7"
```

### 定义型绑定
而在ES5中，`Function.prototype`还提供了`bind`来绑定`this`指代的上下文：
```js
function showName() {
  console.log('my name is:'+this.name);
}

var student = {
  name: 'wxj',
  age: 13
};

var showWxjName = showName.bind(student);
showWxjName();
// => "my name is:wxj"
```

### underscore提供的bind
underscore中也提供了绑定函数上下文的方法`_.bind`和`_.bindAll`
